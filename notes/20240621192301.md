# 20240621192301 Odoo: Server framework 101

#Odoo

## Chapter 1: Architecture Overview

### Multitier application

- Odoo follows a multitier architecture, meaning that the presentation, the business logic, and the data storage are separated.
- The presentation tier is a combination of HTML5, CSS, and JavaScript.
- The logic  tier is exclusively written in Python.
- The data tier only support PostgreSQL as an RDBMS.
- Since version 15.0, Odoo is actively trasitioning to using its own in-house developer OWL framework as part of its presentation tier.
- The legacy JavaScript framework is still supported but will be deprecated over time.

### Odoo modules

- A module is a collection of functions and data that target a single purpose.
- Modules can either add brand new business logic or alter and extend existing business logic.
- Everything in Odoo starts and ends with modules.
- Developers group their business features in Odoo modules.
- The main user-facing modules are flagged and exposed as Apps, but a majority ot the modules aren't Apps.
- Modules may also be referred to as addons and the directories whre the Odoo server finds them form the `addons_path`.

#### Composition of a module

- Business objects \
  A business object (e.g. an invoice) is declared as Python class. The fields defined is these classes are automatically mapped to database columns. Thanks to the ORM layer.
- Object views \
  Define UI display
- Data files \
  XML or CSV files declaring the model data:
  - views or reports
  - configuration data (modules parametrization, security rules)
  - demonstration data
- Web controllers \
  Handle requests from web browsers.
- Static web data \
  Images, CSS, or JavaScript files used by the web interface or website.
- NOTE: none of these elements are mandatory. Some modules may only add data files (e.g. country-specific accounting configuration), while others may only add business objects.

#### Module structure

- Each module is a directory within a module directory.
- Module directories are specified by using the `--addons-path` option.
- An Odoo module is declared by its `__manifest__.py`.
- When an Odoo module includes business objects (i.e. Python files), they are organized as a Python package with a `__init__.py` file. This file contains import instructions for various Python files in the module.

```
addons/
 └── module/
      ├── models/
      │   ├── *.py
      │   └── __init__.py
      ├── data/
      │   └── *.xml
      ├── __init__.py
      └── __manifest__.py
```

### Odoo Editions

- Odoo is available in two versions:
  - Odoo Enterprise (licensed & shared sources)
  - Odoo Community (open-source)
- The Enterprise version provides extra functionalities to Odoo.
- From a technical point-of-view, these functionalities are simply "new modules installed on top of the modules provided by the Community version".


## Chapter 2: A New Application

- The purpose of this chapter is to lay the foundation for the creation of a completely new Odoo module.
- We will start from scratch with the minimum needed to have our module recognized by Odoo.
- In the upcoming chapter, we will progressively add features to build a realistic business case.

### The Real Estate Advertisement module

- Our new module will cover a business area which is very spcific and therefore not included in the standard set of modules: real estate.
- It is worth nothing that before developing a new module.
- It is good practice to verify that Odoo doesn't already provide a way to answer the specific business case.

### Prepare the addon directory

- The first step of module creation is to create its directory.
- In the `tutorials` directory, add new directory `estate`.
- A module must contain a least 2 files:
  - the `__manifest__.py` file and a `__init__.py` file
- The `__init__.py` file can remain empty for now and we'll come back to it in the next chapter.
- The `__manifest__.py` file must describe our module and cannot remain empty. Its only required field is the `name`, but it usually contains much more information.
- Take a look at the CRM file <https://github.com/odoo/odoo/blob/fc92728fb2aa306bf0e01a7f9ae1cfa3c1df0e10/addons/crm/__manifest__.py#L1-L67> as an example.
- In addition to providing the description of the module (`name`, `category`, `summary`, `website`, ...), it lists its dependencies (`depends`).
- A dependencies means that the Odoo framework will ensure that these modules are installed before our module is installed.
- Moreover, if one of these dependencies is uninstalled, the our module and any other that depends on it will also be uninstalled.

#### Exercise

- Create the following directories and files:
  - `./addons/estate/__init__.py`
  - `./addons/estate/__manifest__.py`
- The `__manifest__.py` file should only define the `name` and `depends` of Odoo modules. The only necessary framework module for now is `base`.
  ```python
  # __manifest__.py
  {
      'name': 'Real Estate',
      'depends': ['base']
  }
  ```
- Restart Odoo server and go to Apps. Enable Developer Mode. Click on Update Apps List, search for `estate`.
- Make your module an 'App'.
- Add the appropriate key to your `__manifest__.py` so that the module appears when the 'Apps' filter in on.
  ```python
  # __manifest__.py
  {
      'name': 'Real Estate',
      'depends': ['base'],
      'application': True
  }
  ```


## Chapter 3: Models and Basic Fields

> **WARNING**
> - Do not use mutable global variables.
> - A single Odoo instance can run several databases in parallel within the same Python process.
> - Distinct modules might be installed on each of these database, therefore we cannot rely on global variables that would be updated depending on installed modules.

### Object-Relational Mapping

- A key componen of Odoo is the ORM layer.
- This layer avoids having to manually write most SQL and provides extensibility and security services.
- Business objects are declared as Python classes extending Model, which integrates them into the automated persistence system.
- Models can be configured by setting attributes in their definition.
- The most important attribute is `_name`, which is required and defines the name for the model in the Odoo system.
  ```python
  from odoo import models

  class TestModel(models.Model):
      _name = "test_model"
  ```
- The definition is enough for the ORM to generate a database table named `test_model`.
- By convention, all models are located in a `models` directory and each model is defined in its own Python file.

Take a look at how the `crm_recurring_plan` table is defined and how the corresponding Python file is imported:

- The model is defined in the file `crm/models/crm_recurring_plan.py`
- The file `crm_recurring_plan.py` is imported in `crm/models/__init__.py`
- The folder `models` is imported in `crm/__init__.py`

### Model fields

- Fields are used to define what the model can store and where they are stored.
- Fields are defined as attributes in the model class.
  ```python
  from odoo import fields, models

  class TestModel(models.Model):
      _name = "test_model"
      _description = "Test Model"

      name = fields.Char()
  ```
- The `name` field is a `Char` which will be represented as a Python unicode `str` and a SQL `VARCHAR`.

#### Types

- There are two broad categories of fields:
  - `simple` fields, which are atomic values stored directly in the model's table.
  - `relational` fields, which link records (of the same or different models).
- Simple fields examples are `Boolean`, `Integer`, `Float`, `Char`, `Text`, `Date`, and `Selection`.

#### Common Attributes

- Much like the model itself, fields can be configured by passing configuration attributes as parameters
  ```python
  name = fields.Char(required=True)
  ```
- Some attributes area available on all fields, here are the most common ones:
  - `string` (`str`, **default**: field's name) \
    The label of the fields in UI (visible by users)
  - `required` (`boold`, **default**: `False`) \
    If `True`, the field can not be empty. It must eigher have a default value or always be given a value when creating a record.
  - `help` (`str`, **default**: `''`) \
    Provides long-form help tooltip for users in the UI.
  - `index` (`bool`, **default**: `False`) \
    Request that Odoo create a database index on the column.

#### Automatic Fields

- You may have noticed your model has a few fields your never defined.
- Odoo creates a few fields in all models.
- These fields managed by system and can't be written to, but they can be read if useful or necessary:
  - `id` (Id) \
    The unique identifier for a rcord of the model.
  - `create_date` (Datetime) \
    Creation date of the record.
  - `create_uid` (Many2one) \
    User who created the record.
  - `write_date` (Datetime) \
    Last modification date of the record.
  - `write_uid` (Many2one) \
    User who last modification the record.


## Chapter 4: Security - A Brief Introduction

- In a business application such as Odoo, one of the first questions to consider is who can access the data.
- Odoo provides a security mechanism to allow access to the data for specific groups of users.

### Data Files (CSV)

- Odoo is a highly data driven system. Although behavior is customized using Python code, part of a module's values is in the data it sets up when loaded.
- One way to load data is through a CSV file.
- One example is the list of country states <https://github.com/odoo/odoo/blob/17.0/odoo/addons/base/data/res.country.state.csv> which is loaded at installation of the `base` module.
  ```csv
  "id","country_id:id","name","code"
  state_au_1,au,"Australian Capital Territory","ACT"
  state_au_2,au,"New South Wales","NSW"
  state_au_3,au,"Northern Territory","NT"
  state_au_4,au,"Queensland","QLD"
  ...
  ```
  - `id` is an external identifier. It can be used to refer to the record (without knowing its in-database identifier).
  - `country_id:id` refers to the country by using its external identifier.
  - `name` is the name of the state.
  - `code` is the code of the state.
- These three fields area defined in the `res.country.state` model.
- By convention, a file importing data is located in the `data/` directory of a module.
- When data is related to security, it is located in the `security/` directory.
- When data is related to views and actions, it is located in the `views/` directory.
- Additionally, all of these files must be declared is the `data/` list within the `__manifest__.py` file. The data files are squentially loaded following their order in `__manifest__.py` file.
- Also note that the content of the data files is only loaded when a module is installed or updated.
- Why is all this important for security? Because all the security configuration of a model is loaded through data files, as we'll see in the next section.

### Access Rights

- When no access rights are defined on a model, Odoo determines that no users can access the data. It is even notified in the log.
- Access rights are defined as records of the model `ir.model.access`.
- Each access right is associated with a model, a group (or no group for global access).
- And a set of permissions: create, read, write, and unlink
- Such access rights are usually defines in a CSV file name `ir.model.access.csv`.
  ```
  id,name,model_id/id,group_id/id,perm_read,perm_write,perm_create,perm_unlink
  access_test_model,access_test_model,model_test_model,base.group_user,1,0,0,0
  ```
  - `id` is an external identifier.
  - `name` is the name of the `ir.model.access`.
  - `model_id/id` refers to the model which the access right applies to. The standard way to refer to the model is `model_<model_name>`, where `<model_name>` is the `_name` of the model with the `.` replaced by `_`.
  - `group_id/id` refers to the group which the access right applies to.
  - `perm_read,perm_write,perm_create,perm_unlink`: read, write, create, and unlink permissions (unlink is the equivalent of delete).


## Chapter 5: Finally, Some UI to Play With

### Data Files (XML)

- In Chapter 4, we added data through a CSV file. The CSV format is convenient when the data to load has a simple format.
- When the format is more complex (e.g. load the structure of a view or an email template), we use XML format. For example, the data that contain HTML tags.
- While it would be possible to load such data through a CSV file, it is more convenient to use XML file.
- When performance is important, CSV format is preferred over the XML format. This is the case in Odoo where loading a CSV file is faster than loading an XML file.
- In Odoo, the UI (actions, menus, and views) is largely defined by creating and composing records defined in an XML file.
- A common pattern is Menu > Action > View.
- To access records the user navigates through several menu level. The deepest level is an action which triggers the opening of a list of the records.

#### Actions

- Actions can be triggered in 3 ways:
  1. by clicking on menu items (linked to specific actions)
  2. by clicking on buttons in views (if these are connected to actions)
  3. as contextual actions on object
- A basic action for out `test_model` is:
  ```xml
  <record id="test_model_action" model="ir.actions.act_window">
      <field name="name">Test action</field>
      <field name="res_model">test_model</field>
      <field name="view_mode">tree,form</field>
  </record>
  ```
  - `id` is an external identifier. It can be used to refer to the record (without knowing its in-database identifier).
  - `model` has a fixed value of `ir.actions.act_window` (Window Actions (ir.actions.act_window))
  - `name` is the name of the action.
  - `res_model` is the model which the action applies to.
  - `view_mode` are the views that will be available.

#### Menus

- To reduce the complexity in declaring a menu (`ir.ui.menu`) and connectiong it to the corresponding action, we can use the `<menuitem>` shortcut.
- A basic menu for our `test_model_action` is:
  ```xml
  <menuitem id="test_model_menu_action" action="test_model_action"/>
  ```
- The menu `test_model_menu_action` is linked to the action `test_model_action`, and the action is linked to the model `test_model`.
- As previously mentioned, the action can be seen as the link between the menu and the model.
- However, menus always follow an architecture, and in practice there are 3 levels of menus:
  1. The root menu, which is displayed in the App switcher (the Odoo Community App Switcher is a dropdown menu).
  2. The first level menu, displayed in the top bar.
  3. The action menus.

### Fields, Attributes, and View

- So far we have only used the generic view for our real estate property advertisements, but in most cases we want to find tune the view.
- There are many fine-tunings possible in Odoo, but usually the first step is to make sure that:
  - some fields have a default value
  - some fields are read-only
  - some fields are not copied when duplicating the record
- In our real estate business case, we would like the following:
  - The selling price should be read-only (it will be automatically filled in later)
  - The availability date and the selling price should not be copied when duplicating a record
  - The default number of bedrooms should be 2
  - The default availability date should be in 3 months

#### Some New Attributes

- Before moving further with the view design, let's step back to our model definition.
- We saw that some attributes, such as `required=True`, impact the table schema in the database. Other attributes will impact the view or provide default values.
- The appropriate attributes you can check on ORM API > fields <https://www.odoo.com/documentation/17.0/developer/reference/backend/orm.html#odoo.fields.Field>

#### Default Values
- Any field can be given a default value.
- In the field definition, add the option `default=X` where `X` is either a Python literal value (boolean, integer, float, string) or a function taking a model and returning a value:
  ```python
  name = fields.Char(default="Unknown")
  last_seen = fields.Datetime("Last Seen", default=fields.Datetime.now)
  ```
- The `name` field will have the value `Unknown` by default while the `last_seen` field will be set as the current time.

#### Reserved Fields

- A few field names are reserved for pre-defined behaviors.
- They should be defined on a model when the related behavior is desired.


## Chapter 6: Basic Views

- In practice, the default view is never acceptable for a business application. Instead, we should at least oragnize the various fields in a logical manner.
- Views are defined in XML files with actions and menus. They are instances of `ir.ui.view` model.
- In our real estate module, we need to organize the fields in a logical way:
  - in the list (tree) view, we want to display more than just the name.
  - in the form view, the fields should be grouped.
  - in the search view, we must be able to search on more than just the name. Specifically, we want a filter for the 'Available' properties and a shortcut to group by postcode.

### List

**Reference**: the documentation related to this topic can be found in [**List**](https://www.odoo.com/documentation/17.0/developer/reference/user_interface/view_architectures.html#reference-view-architectures-list).

- List views, also called tree views, display records in a tabular form.
- Their root element is `<tree>`.
- The most basic version of this view simply lists all the fields to display in the table (where each field is a column):
  ```xml
  <tree string="Tests">
      <field name="name"/>
      <field name="last_seen"/>
  </tree>
  ```

  > **Warning**
  >
  > You will probably use some copy-paste in this chapter, therefore always make sure that `id` remains unique for each view!

### Form

**Reference**: the documentation related to this topoic can be found in [**Form**](https://www.odoo.com/documentation/17.0/developer/reference/user_interface/view_architectures.html#reference-view-architectures-form).

- Forms are used to create and edit single records.
- Their root element is `<form>`.
- They are composed of high-level structure elements (groups and notebooks) and interactive elements (buttons and fields):
  ```xml
  <form string="Test">
      <sheet>
          <group>
              <group>
                  <field name="name"/>
              </group>
              <group>
                  <field name="last_seen"/>
              </group>
          </group>
          <notebook>
              <page string="Description">
                  <field name="description"/>
              </page>
          </notebook>
      </sheet>
  </form>
  ```
- It is possible to use regular HTML tags such as `div` and `h1` as well as the `class` attribute (Odoo provides some built-in classes) to fine-tune the look.
- A simple example can be found [here](https://github.com/odoo/odoo/blob/6da14a3aadeb3efc40f145f6c11fc33314b2f15e/addons/crm/views/crm_lost_reason_views.xml#L16-L44).
- In order to avoid relaunching the server every time you do a modification to the view, it can be convenient to use the `--dev xml` parameter when launching the server. This parameter allows you to just refresh the page to view your view modifications.

### Search

**Reference**: the documentation related to this topic can be found in [**Search**](https://www.odoo.com/documentation/17.0/developer/reference/user_interface/view_architectures.html#reference-view-architectures-search).

- Search views are slightly different from the list and form views since they don't display content.
- Although they apply to a specific model, they are used to filter other views' content (general aggregated views such as List).
- Beyond the difference is use case, they are defined the same way.
- Their root element is `<search>`.
- The most basic version of this view simply lists all the fields for which a shortcut is desired:
  ```xml
  <search string="Tests">
      <field name="name"/>
      <field name="last_seen"/>
  </search>
  ```
- The default search view generated by Odoo provides a shortcut to filter by `name`.
- It is very common to add the fields which the user is likely to filter on in a customized search view.
- Search views can also contain `<filter>` elements, which act as toggles for predefined searches.
- Filters must have one of the following attributes:
  - `domain` adds the given domain to the current search
  - `context` adds some context to the current search; uses the key `group_by` to group results on the given field name
- A simple example can be found [**here**](https://github.com/odoo/odoo/blob/715a24333bf000d5d98b9ede5155d3af32de067c/addons/delivery/views/delivery_view.xml#L30-L44).
  ```xml
  <record id="view_delivery_carrier_search" model="ir.ui.view">
      <field name="name">delivery.carrier.search</field>
      <field name="model">delivery.carrier</field>
      <field name="arch" type="xml">
          <search string="Delivery Carrier">
              <field name="name" string="Carrier" />
              <field name="delivery_type"/>
              <separator/>
              <filter string="Archived" name="inactive" domain="[('active', '=', False)]"/>
              <group expand="1" string="Group By">
                  <filter string="Provider" name="provider" context="{'group_by':'delivery_type', 'residual_visible':True}"/>
              </group>
          </search>
      </field>
  </record>
  ```

#### Domains

**Reference**: the documentation related to this topic can be found in [**Search domains**](https://www.odoo.com/documentation/17.0/developer/reference/backend/orm.html#reference-orm-domains).

- In Odoo, a domain encodes conditions on records: a domain is a list of criteria used to select a subset of a model's records.
- Each criterion is a triplet with a field `name`, an `operator`, and a `value`.
- A record satisfies a criterion if the specified field meets the condition of the operator applied to the value.
- For instance, when used on the Product model the following domain selects all services with a unit price greater than 1000:
  ```xml
  [('product_type', '=', 'service'), ('unit_price', '>', 1000)]
  ```
- By default criteria are combined with an impicit AND, meaning every criterion needs to be satisfied for a record to match a domain.
- The logical operators `&` (AND), `|` (OR), `!` (NOT) can be used to explicitly combine criteria.
- They are used in prefix position (the operator is inserted before its arguments rather than between).
- For instance, to select products 'which are services OR have a unit price which is NOT between 1000 and 2000':
  ```xml
  ['|',
      ('product_type', '=', 'service'),
      '!', '&',
          ('unit_price', '>=', 1000),
          ('unit_price', '<', 2000)]
  ```
- XML does not allow `<` and `&` to be used inside XML elements. To avoid parsing errors, entity references should be used: `&lt;` for `<` and `&amp;` for `&`. Other references (`&gt;`, `&apos;`, `&quot;`) are optional.
  ```xml
  <filter name="negative" domain="[('test_val', '&lt;', 0)]"/>
  ```


## Chapter 7: Relations Between Models

- In any real business scenario we need more than one model.
- Moreover, links between models are necessary.
- One can easily imagine one model containing the customers and another one containing the list of users.
- You might need to refer to a customer or a user on any existing business model.
- In our real estate module, we want the following information for a property:
  - the customer who bought the property
  - the real estate agent who sold the property
  - the property type: house, apartment, penthouse, castle, ...
  - a list of tags characterizing the property: cozy, renovated, ...
  - a list of the offers received

### Many2one

**Reference**: the document related to this topic can be found in [**Many2one&**](https://www.odoo.com/documentation/17.0/developer/reference/backend/orm.html#odoo.fields.Many2one).

- In our real estate module, we want to define the concept of property type.
- A property type is, for example, a house or an apartment.
- It is a standard business neeed to categorize properties according to their type, especially to refine filtering.
- A property can have **one** type, but the same type can be assigned to **many** properties.
- This is supported by the **many2one** concept.
- A many2one is a simple link to another object.
- For example, in order to define a link to the `res.partner` in our test model, we can write:
  ```python
  partner_id = fields.Many2one("res.partner", string="Partner")
  ```
- By convention, many2one fields have the `_id` suffix.
- Accessing the data in the partner can then be easily done with:
  ```xml
  print(my_test_object.partner_id.name)
  ```
- See also [**foreign keys**](https://www.postgresql.org/docs/12/tutorial-fk.html)
- In pratice a many2one can be seen as a dropdown list in a form view.
- In the real estate module, there are still two missing pieces of information we want on a property: the buyer and the salesperson.
- In buyer can be any individual, but on the other hand the salesperson must be an employee of the real estate agency (i.e. an Odoo user).
- In Odoo, there are two models which we commonly refer to:
  - `res.partner`, a partner is a physical or leagl entity. It can be a company, an individual or even a contact address.
  - `res.users`, the users of the system. Users can be 'internal', i.e. they have access to the Odoo backend. Or they can be 'portal', i.e. they cannot access the backend, only the frontend (e.g. to access their previous orders in eCommerce).

### Many2many

**Reference**: the documentation related to this topic can be found in [Many2many](https://www.odoo.com/documentation/17.0/developer/reference/backend/orm.html#odoo.fields.Many2many).

- In our real estate module, we want to define the concept of property tags.
- A property tag is, for example, a property which is 'cozy' or 'renovated'.
- A property can have many tags and a tag can be assigned to many properties. This is supported by the many2many concept.
- A many2many is a bidirectional multiple relationship: any record on one side can be related to any number of records on the other side.
- For example, in order to define a link to the `account.tax` model on our test model, we can write:
  ```python
  tax_ids = fields.Many2many("account.tax", string="Taxes")
  ```
- By convention, many2many fields have the `_ids` suffix.
- This means that several taxes can be added to our test model.
- It behaves as a list of records, meaning htat accessing the data must be done in a loop:
  ```python
  for tax in my_test_object.tax_ids:
      print(tax.name)
  ```
- A list of records is know as recordset, i.e. an ordered collection of records. It supports standard Python operations on collections, such as `len()` and `iter()`, plus extra set operations like `recs1 | recs2`

### One2many

**Reference**: the documentation realted to this topic can be found in [One2many](https://www.odoo.com/documentation/17.0/developer/reference/backend/orm.html#odoo.fields.One2many).

- In our real estate module, we want to define the concept of property offers.
- A property offer is an amount a potential buyer offers to the seller.
- The offer can be lower or higher than the expected price.
- An offer applies to one property, but the same property can have many offers.
- The concept of many2one appears once again.
- However, in this case we want to display the list of offers for a given property so we will use the one2many concept.
- An one2many is the inverse of a many2one. For example, we defined on our test model a link to the `res.partner` model thanks to the field `partner_id`.
- We can define the inverse relation, i.e. the list of test models linked to our partner:
  ```python
  test_ids = fields.One2many("test_model", "partner_id", string="Tests")
  ```
- The first parameter is called the `comodel` and the second parameter is the field we want to inverse.
- By convention, one2many fields have the `_ids` suffix. They behave as a list of records, meaning that accessing the data must be done in a loop:
  ```python
  for test in partner.test_ids:
      print(test.name)
  ```

  > **Danger**
  >
  > Because a `One2many` is a virtual relationship, there must be a `Many2one` field defined in the comodel.

- There are several important things to notice here:
  1. First, we don't need an action or a menu for all models. Some models are intended to be accessed only through another model. This is the case in our exercise: an offer is always accessed through a property.
  2. Second, despite the fact that the `property_id` field is required, we did not include it in the views. How does Odoo know which property our offer is linked to? Well that's part of the magic of using Odoo framework: sometimes things are defined implicitly. When we create a record through a one2many field, the corresponding many2one is populated automatically for convenience.


## Chapter 8: Computed Fields And Onchanges

- The relation between modesl are a key componen of any Odoo module. They are necessary for the modelization of any business case.
- However, we may want links between the fields within a given model.
- Sometimes, the value of one field is determined from the values of other fields and other times we want to help the user with data entry.
- These cases are supported by the concepts of computed fields and onchanges.
- Although this chapter is not technically complex, the semantics of both concepts is very important.
- This is also the first time we will write Python logic. Until now we haven't anything other than class definitions and field declarations.

### Computed Fields

**Reference**: the documentation related to this topic can be found in [**Compouted Fields**](https://www.odoo.com/documentation/17.0/developer/reference/backend/orm.html#reference-fields-compute)

- In our real estate module, we have defined the living area as well as the garden area.
- It is then naturan to define the total area as the sum of both fields.
- We will use the concept of a computed field for this, i.e. the value of a given field will be computed from the value of other fields.
- So far fields have been stored directly in and retrieved directly from the database.
- Fields can also be computed. In this case, the field's value is not retrieved from the database but computed on-the-fly by calling a method of the model.
- To create a computed field, create a field and set its attribute `compute` to the name of a mtehod.
- The computation method should set the value of the computed field for every record in `self`.
- By convention, `compute` methods are private, meaning that they cannon be called from the presentation tier, only from the business tier.
- Private methods ave a name starting with an underscore `_`.

#### Dependencies

- The value of a computed field usually depends on the values of other fields in the computed record.
- The ORM expects the developer to specify those dependencies on the compute method with the decorator `depends()`.
- The given dependencies are used by the ORM to trigger the recomputation of the field whenever some of its dependencies have been modified:
  ```python
  form odoo import api, fields, models

  class TestComputed(models.Model):
      _name = "test.computed"

      total = fields.Float(compute="_compute_total")

      @api.depends("amount")
      def _compute_total(self):
          for record in self:
              record.total = 2.0 * record.amount
  ```
  > **Note**
  >
  > `self` is a collection.
  > The object `self` is a recordset, i.e. and ordered collection of records. It supports the standard Python operation on collections, e.g. `len(self)` and `iter(self)`, plus extra set operations such as `recs1 | recs2`.
  >
  > Iterating over `self` gives the records one by one, whre each record is itself a collectin of size 1. You can access/assign fields on single records by using the dot notation, e.g. `record.name`.

- Many examples of computed fields can be found in Odoo. [**Here**](https://github.com/odoo/odoo/blob/713dd3777ca0ce9d121d5162a3d63de3237509f4/addons/account/models/account_move.py#L3420-L3423) is a simple one.

#### Inverse Function

- You might have noticed that computed fields are read-only by default.
- This is expected since the user is not supposed to set a value.
- In some cases, it might be useful to still be able to set a value directly.
- In our real estate example, we can define a validity duration for an offer and set a validity date.
- We would like to be able to set either the duration or the date with one impacting the other.
- To support this Odoo provides the ability to use an `inverse` function:
  ```python
  from odoo import api, fields, models

  class TestComputed(models.Model):
      _name = "test.computed"

      total = fields.Float(compute="_compute_total", inverse="_inverse_total")
      amount = fields.Float()

      @api.depends("amount")
      def _compute_total(self):
          for record in self:
              record.total = 2.0 * record.amount

      def _inverse_total(self):
          for record in self:
              record.amount = record.total / 2.0
          ```
          - An example can be found [**here**](https://github.com/odoo/odoo/blob/2ccf0bd0dcb2e232ee894f07f24fdc26c51835f7/addons/crm/models/crm_lead.py#L308-L317).
- A compute method sets the field while an inverse method sets the field's dependencies.
- Note that the `inverse` method is calling when saving the record, while the `compute` method is called at each change of its dependencies.

#### Additional Information

- Computed fields are not stored in the database by default.
- Therefore it is not possible to search on a computed field unless a `search` method is defined.
- This topic is beyond the scope of this training, so we won't cover it.
- An example can be found [**here**](https://github.com/odoo/odoo/blob/f011c9aacf3a3010c436d4e4f408cd9ae265de1b/addons/event/models/event_event.py#L188).
  ```python
  description = fields.Char(compute="_compute_description", store=True)
  partner_id = fields.Many2one("res.partner")

  @api.depends("partner_id.name")
  def _compute_description(self):
      for record in self:
          record.description = "Test for partner %s" % record.partner_id.name
  ```
- Every time the partner `name` is changed, the `description` is automatically recomputed for all the records refering to it!
- This can quickly become prohibitive to recompute when millions of records need recomputation.
- It is also worth nothing that a computed field can depend on another computed field.
- The ORM is smart enough to correctly recompute all the dependencies in the right order...but sometimes at the cost of degraded performance.
- In general performance must always be kept in mind when defining computed fields.
- The more complex is your field to compute (e.g. with a lot of dependencies or when a computed field depends on other computed fields), the more time it will take to compute. = 
- Always take some time to evaluate the cost of a computed field beforehand. Most of the time it is only when your code reaches a production server that you realize it slows down a whole process. Not cool :-(

### Onchanges

**Reference**: the documentation related to this topic can be found in [onchange()](https://www.odoo.com/documentation/17.0/developer/reference/backend/orm.html#odoo.api.onchange).

- In our real estate module, we also want to help the user with data entry.
- When the 'garden' field is set, we want to give a default value for the garden area as well as the orientation.
- Additionally, when the 'garden' field is unset we want the garden area to reset to zero and the orientation to be removed.
- In this case, the value of a given field modifies the value of other fields.
- The 'onchange' mechanism provides a way for the client interface to update a form without saving anything to the database whenever the user has filled in a field value.
- To achieve this, we define a method where `self` represents the record in the form view and decorate it with `onchange()` to specify which field it is triggered by.
- Any change you make on `self` will be relected on the form:
  ```python
  from odoo import api, fields, models

  class TestOnchange(models.Model):
      _name = "test.onchange"

      name = fields.Char(string="Name")
      description = fields.Char(string="Description")
      partner_id = fields.Many2one("res.partner", string="Partner")

      @api.onchange("partner_id")
      def _onchange_partner_id(self):
          self.name = "Document for %s" % (self.partner_id.name)
          self.description = "Default description for %s" % (self.partner_id.name)
  ```
- In this example, changing the partner will also change the name and the description values.
- It is up to the user whether or not to change the name and description values afterwards.
- Also note that we do not lop on `self`, this is because the method is only triggered in a form view, where `self` is always a single record.

#### Additional Information

- Onchanges methods can also return a non-blocking warning message ([**example**](https://github.com/odoo/odoo/blob/cd9af815ba591935cda367d33a1d090f248dd18d/addons/payment_authorize/models/payment.py#L34-L36)).

### Ho to use them?

- This is no strict rule for the use of computed fields and onchanges.
- I many cases, both computed fields and onchanges may be used to achieve the same result.
- Always prefer computed fields since they are also triggered outside of the context of a form view.
- Never ever use an onchange to add business logic to your model. This is very bad idea since onchanges are not automatically trigerred when creating a record programmatically; they are only triggered in the form view.
- The usual pitfall of computed fields and onchanges is trying to be 'too smart' by adding too much logic. This can have the opposite result of what was expected: the end user is confused from all the automation.
- Computed fields tend to be easier to debug: such a field is set by a given method, so it's easy to track when the value is set.
- Onchanges, on the other hand, may be confusing: it is very difficult to know the extent of an onchange. Since several onchange methods may set the same fields, it easily becomes difficult to track where a value is coming from.
- When using stored computed fields, pay close attention to the dependencies. When computed fields depend on other computed fields, chaning a vlue can trigger a large number of recomputations. This leads to poor performance.


## Chapter 9: Ready for Some Action?

- So far we have mostly built our module by declaring fields and views.
- We just introduced business logic in the previous chapter thanks to computed fields and onchanges.
- In any real business scenario, we would want to link some business logic to action buttons.
- In our real estate example, we would like to be able to:
  - cancel or set a property as sold
  - accept or refuse an offer
- One could argue that we can already do these things by changing the state manually, but this is not really convenient.
- Moreover, we want to add some extra processing: when an offer is accepted we want to set the selling price and the buyer for the property.

### Object Type

**Reference**: the documentation related to this topic can be found in [**Actions**](https://www.odoo.com/documentation/17.0/developer/reference/backend/actions.html) and [**Error managemenet**](https://www.odoo.com/documentation/17.0/developer/reference/backend/orm.html#reference-exceptions).

- In our real estate module, we want to link business logic with some buttons.
- The most common way to do this is to:
  - Add a button in the view, for example in the `header` of the view:
    ```xml
    <form>
        <header>
            <button name="action_do_something" type="object" string="Do Something"/>
        </header>
        <sheet>
            <field name="name"/>
        </sheet>
    </form>
    ```
  - And link this button to business logic:
    ```python
    from odoo import fields, models

    class TestAction(models.Model):
        _name = "test.action"

        name = fields.Char()

        def action_do_something(self):
            for record in self:
                record.name = "Something"
            return True
    ```
- By assigning `type="object"` to our button, the Odoo framework will execute a Python method with `name="action_do_something"` on the given model.
- The first important detail to note is that our method name isn't prefixed with an underscore (`_`). This makes our method a public method, which can be called directly from the Odoo interface (through an RPC call). Until now, all methods we created (compute, onchange) were called internally, so we used private methods prefixed by an underscore. Youshould always define your methods as private unless they need to be called from the user interface.
- Also note that we loop on `self`. Always assume that a method can be called on multiple records; it's better for reusability.
- Finally, a public method should always return something so that it can be called through XML-RPC. When in doubt, just `return True`.

### Action Type

- In Chapter 5: Finally, Some UI to Play With, we created an action taht was linked to a menu. Yo may wondering if it is possible to link an action to a button. Good news, it is! One way to do it is:
  ```xml
  <button type="action" name="%(test.test_model_action)d" string="My Action">
  ```
- We use `type="action"` and we refer to the external identifier in the `name`.


## Chapter 10: Constaints

- The previous chapter introduced the ability to add some business logic to our model.
- We can now link buttons to business code, but how can we prevent uses from entering incorrect data? For example, in our real estate module nothing prevents users from setting a negative expected price.
- Odoo provides two ways to set up automatically verified invariants: [`Python constraints`](https://www.odoo.com/documentation/17.0/developer/reference/backend/orm.html#odoo.api.constrains) and `SQL constraints`.

### SQL

**Reference**: the documentation related to this topic can be found in [**Models**](https://www.odoo.com/documentation/17.0/developer/reference/backend/orm.html#reference-orm-models) and in the [**PostgreSQL's documentation**](https://www.postgresql.org/docs/12/ddl-constraints.html).

- SQL constraints are defined through the model attribute `_sql_constraints`. This attribute is assigned a lit of triples containing string `(name, sql_definition, message)`, where `name` is valid SQL constraint name, `sql_definition` is a [**table_constraint**](https://www.postgresql.org/docs/12/ddl-constraints.html) expressioon and `message` is the error message.
- You can find a simple example [**here**](https://github.com/odoo/odoo/blob/24b0b6f07f65b6151d1d06150e376320a44fd20a/addons/analytic/models/analytic_account.py#L20-L23).

### Python

**Reference**: the documentation related to this topic can be found in [constrains()](https://www.odoo.com/documentation/17.0/developer/reference/backend/orm.html#odoo.api.constrains).

- SQL constraints are an efficient way of ensuring data consistency.
- However, it may be necessary to make more complex checks which require Python code. In this case we need a Python constraint.
- A Python constraint is defined as a method decorated with `constrains()` and is invoked on a recordset.
- The decorator specifies which fields are involved in the constraint.
- The constraint is automatically evaluated when any of these fields are modified.
- The method is expected to raise an exception if its invariant is not satisfied.
  ```python
  from odoo.exceptions import ValidationError

  @api.constrains("date_end")
  def _check_date_end(self):
      for record in self:
          if record.date_end < fields.Date.today():
              raise ValidationError("The end date cannot be set in the past.")
      # all records passed the test, don't return anything
  ```
- A simple example can be foun [**here**](https://github.com/odoo/odoo/blob/274dd3bf503e1b612179db92e410b336bfaecfb4/addons/stock/models/stock_quant.py#L239-L244).
- SQL constraints are usually more efficient than Python constraints. When performance matters, always perefer SQL over Python constraints.


## Chapter 11: Add The Sprinkles

- Our real estate module now makes sense from a business perspective.
- We created specific views, added several action buttons, and constraints.
- However our user interface is still a bit rough. We would like to add some colors to the list views and make some fields and buttons conditionally disappear.
- For example, the 'Sold' and 'Cancel' buttons should disappear when the property is sold or canceled since it it no longer allowed to change the state at this point.
- This chapter covers a very small subset of what can be done in the views.
- Do not hesitate to read the reference documentation for a more complete overview.

**Reference**: the documentation related to this chapter can be found in [**View records**](https://www.odoo.com/documentation/17.0/developer/reference/user_interface/view_records.html) and [**View architectures**](https://www.odoo.com/documentation/17.0/developer/reference/user_interface/view_architectures.html).

### Inline Views

- In the real estate module we added a list of offers for a property. We simply added the field `offer_ids` with:
  ```xml
  <field name="offer_ids"/>
  ```
- The field uses the specific view for `estate.property.offer`.
- In some cases we want to define a specific list view which is only used in the context of a form view.
- For example, we would like to display the list of properties linked to a property type.
- However, we only want to display 3 fields for clarity: name, expected price, and state.
- To do this, we can define inline list views. An inline list view is defined directly inside a form view. For example:
  ```python
  from odoo import fields, models

  class TestModel(models.Model):
      _name = "test_model"
      _description = "Test Model"

      description = fields.Char()
      line_ids = fields.One2many("test_model_line", "model_id")

  class TestModelLine(models.Model):
      _name = "test_model_line"
      _description = "Test Model Line"

      model_id = fields.Many2one("test_model")
      field_1 = fields.Char()
      field_2 = fields.Char()
      field_3 = fields.Char()
  ```
  ```xml
  <form>
      <field name="description"/>
      <field name="line_ids">
          <tree>
              <field name="field_1"/>
              <field name="field_2"/>
          </tree>
      </field>
  </form>
  ```
- In the form view of the `test_model`, we define a specific list view for `test_model_line` with fields `field_1` and `field_2`.
- An example can be found [**here**](https://github.com/odoo/odoo/blob/0e12fa135882cd5095dbf15fe2f64231c6a84336/addons/event/views/event_tag_views.xml#L27-L33).

### Widgets

**Reference**: the documentation related to this section can be found in [**Fields**](https://www.odoo.com/documentation/17.0/developer/reference/frontend/javascript_reference.html#reference-js-widgets).

- Whenever we've added fields to our models, we've (almost) never had to worry about how these about how these fields would look like in the user interface.
- For example, a date picker is provided for a `Date` field and a `One2many` field is automatically displayed as a list. Odoo chooses the right `widget` dependeing on the field type.
- However, in some cases, we want a specific representation of a field which can be done thanks to the `widget` attribute.
- We already used it for the `tags_ids` field when we used the `widget="many2many_tags` attribute. If we hand't used it, then the field would ahve displayed as a list.
- Each field type ahs a set of widgets can be used to fine tune its display. Some widgets also take extra options. An exhaustive list can be found in [**Fields**](https://www.odoo.com/documentation/17.0/developer/reference/frontend/javascript_reference.html#reference-js-widgets).
  > **Warning**
  >
  > Same field multiple times in a view
  >
  > Add a field only **once** to a list or a form view. Adding it multiple times is not supported.

### List Order

**Reference**: the documentation related to this section can be found in [**Models**](https://www.odoo.com/documentation/17.0/developer/reference/backend/orm.html#reference-orm-models).

- During the previous exercises, we created several list views.
- However, at no point did we specify which order the records had to be listed in by default.
- This is a very important thing for many business cases.
- For example, in our real estate module we would want to display the highest offers on top of the list.

#### Model

- Odoo provides several ways to set a default order.
- The most common way is to define the `_order` attribute directly in the model.
- This way, the retrieved records will follow a deterministic order which will be consistent in all views including when records are searched programmatically.
- By default there is no order specified, therefore the records will be retireved in a non-deteministic order depending on PostgreSQL.
- The `_order` attribute takes a string containing a list of fields which will be used for sorting. It will be converted to an [**order_by**](https://www.postgresql.org/docs/12/queries-order.html) clause in SQL. For example:
  ```python
  from odoo import fields, models

  class TestModel(models.Model):
      _name = "test_model"
      _description = "Test Model"
      _order = "id desc"

      description = fields.Char()
  ```
- Our records are ordered by descending `id`, meaning the highest comes first.

#### View

- Ordering is possible at the model level.
- This has the advantage of a consistent order everywhere a list of records is retrieved.
- However, it is also possible to define a specific order directly in a view. Thanks to the `default_order` attribute ([**example**](https://github.com/odoo/odoo/blob/892dd6860733c46caf379fd36f57219082331b66/addons/crm/report/crm_activity_report_views.xml#L30)).
  ```xml
  <record id="crm_activity_report_view_tree" model="ir.ui.view">
      <field name="name">crm.activity.report.tree</field>
      <field name="model">crm.activity.report</field>
      <field name="arch" type="xml">
          <tree default_order="date desc">
              <field name="date"/>
              <field name="author_id"/>
              <field name="mail_activity_type_id"/>
              <field name="body"/>
              <field name="company_id" groups="base.group_multi_company"/>
          </tree>
      </field>
  </record>
  ```

#### Manual

- Both model and view ordering allow flexibility when sorting records, but there is still on e case we need to cover: the manual ordering.
- A user may want to sort records depending on the business logic. For example, in our real estate module we would like to sort the property types manually. It is indeed useful to have the most used types appear at the top of the list. If our real estate agency mainly sells houses, it is more convenient to have 'House' appear before 'Appartment'.
- To do so, a `sequence` field is used in combination with the `handle` widget. Obviously the `sequence` field must be the first field in the `_order` attribute.

### Attributes and options

- It would be prohibitive to detail all the available features which allow fine tuning of the look of a view. Therefore, we'll stick to the most common ones.

#### Form

- In our real estate module, we want to modify the behaviour of some fields.
- For example, we don't want to be able to create or edit a property type from the form view. Instead we expect the types to be handled in their appropriate menu.
- We also want to give tags a color. In order to add these behaviour customizations, we can add the `options` attribute to several field widgets.
- In Chapter 5: Finally, Some UI to Play With, we saw that reserved fields were uses for specific behaviours. For example, the `active` field is used to automatically firlter out inactive records. We added the `state` as a reserved field as well. It's now time to use it! A `state` field can be used in combination with an `invisible` attribute in the view to display buttons conditionally.
- More generally, it is possible to make a field `invisible` , `readonly`, or `required` based on the value of other fields. Note that `invisible` can also be applied to other elements of the view such as `button` or `group`.
- `invisible`, `readonly`, `required` can have any Python expression as value. The expression gives the condition in which the property applies. For example:
  ```xml
  <form>
      <field name="description" invisible="not is_partner"/>
      <field name="is_partner" invisible="True"/>
  </form>
  ```

> **Warning**
>
> Using a (conditional) `readonly` attribute in the view can be useful to prevent data entry errors, but keep in mind that it doesn't provice any level of security! There is no check done server-side, thereofre it's always possible to write on the field through a RPC call.

#### List

- When the model only has a few fields, it can be useful to edit records directly through the list view and not have to open the form view.
- In the real estate example, there is no need to open a form view to add an offer or create a new tag. This can be achieved thanks to the `editable` attribute.
  ```xml
  <record id="estate_property_offer_view_tree" model="ir.ui.view">
    <field name="name">estate_property_offer_view_tree</field>
    <field name="model">estate.property.offer</field>
    <field name="arch" type="xml">
      <tree string="" editable="bottom">
        <field name="price"/>
        <field name="partner_id"/>
        <field name="validity"/>
        <field name="date_deadline"/>
        <field name="property_state" column_invisible="True"/>
        <field name="status"/>
      </tree>
    </field>
  </record>
  ```
- `editable="bottom"` This makes the list view editable, allowing users to add new records at the bottom. You can also use `editable="top"` to add new records at the top of the list.
- On the other hand, when a modle as a lot of fields it can be tempting to add too many fields in the list view and make it unclear.
- An alternative method is to add the fields, but make them optionally hidden. This can be achieved thanks to the `optional` attribute.
  ```xml
  <record id="view_estate_property_tree" model="ir.ui.view">
    <field name="name">estate.property.tree</field>
    <field name="model">estate.property</field>
    <field name="arch" type="xml">
      <tree>
        <field name="name"/>
        <field name="price"/>
        <field name="state"/>
        <!-- Other fields -->
        <field name="date_availability" optional="show"/>
      </tree>
    </field>
  </record>
  ```
- `optional="show"` This attribute makes the field optional in the list view. It means the field can be toggled on or off by the user in the view settings. By default, it will be hidden `optional="hide"`.
- Finally, color codes are useful to visually emphasize records. For example, in the real estate module we would like to display refused offers in red and accepted offer in green. This can be achieved thanks to the `decoration-{$name}` attribute (see [**Fields**](https://www.odoo.com/documentation/17.0/developer/reference/frontend/javascript_reference.html#reference-js-widgets) for a complete list):

#### Search

**Reference**: the documentation related to this section can be found in [**Search**](https://www.odoo.com/documentation/17.0/developer/reference/user_interface/view_architectures.html#reference-view-architectures-search) and [**Search defaults**](https://www.odoo.com/documentation/17.0/developer/reference/user_interface/view_architectures.html#reference-view-architectures-search-defaults).

- Last but not least, there are some tweaks we would like to apply when searching.
- First of all, we want to have our 'Available' filter applied by default when we access the properties.
- To make this happen, we need to use the `search_default_{$name}` action context, where `{$name}` is the filter name.
- This means that we can define which filter(s) will be activated by default at the action level.
- Here is an example of an [**action**](https://github.com/odoo/odoo/blob/6decc32a889b46947db6dd4d42ef995935894a2a/addons/crm/report/crm_opportunity_report_views.xml#L115) with its [**corresponding filter**](https://github.com/odoo/odoo/blob/6decc32a889b46947db6dd4d42ef995935894a2a/addons/crm/report/crm_opportunity_report_views.xml#L68).
- Another useful improvement in our module would be the ability to search efficiently by living area. In practive, a user will want to search for properties of 'at least' the given area.
- It is unrealistic to expect users would want to find a property of an exact living area. It is always possible to make a custom search, but that's inconvenient.
- Serach view `<field>` elements can have a `filter_domain` that overrides the domain generated for searching on the given field.
- In the given domain, `self` represents the value entered by the user. In the example below, it is used to search on both `name` and `description` fields.
  ```xml
  <search string="Test">
      <field name="description" string="Name and description"
             filter_domain="['|', ('name', 'ilike', self), ('description', 'ilike', self)]"/>
  </search>
  ```

### Stat Buttons

- If you're already used some functional modules in Odoo, you've probably already encountered a 'stat button'.
- These buttons are displayed on the top right of a form view and give a quick access to linked documents.
- In our real estate module, we would like to have a quick link to the offers related to a given property type as depiced in the **Goal** of this section.
- At this point of the tutorial we have already seen most of the concepts to do this.
- However, there is not a single solution and it can still be confusing if you don't know where to start from.
- We'll describe a step-by-step solution in the exercise. It can always be useful to find some examples in the Odoo codebase by looking for `oe_stat_button`.
- The following exercise might be a bit more difficult than the previous ones since it assumes you are able to search for examples in the source code on your own. If you are stuck there is probably someone nearby who can help you ;-)
- The exercise introduces the concepts of [**Related fields**](https://www.odoo.com/documentation/17.0/developer/reference/backend/orm.html#reference-fields-related). The easies way to understand it is to consider it as a specific case of a computed field. The following definition of the `description` field:
  ```python
  ...

  partner_id = fields.Many2one("res.partner", string="Partner")
  description = fields.Char(related="partner_id.name")
  ```
  is quivalent to:
  ```python
  ...

  partner_id = fields.Many2one("res.partner", string="Partner")
  description = fields.Char(compute="_compute_description")

  @api.depends("partner_id.name")
  def _compute_description(self):
      for record in self:
          record.description = record.partner_id.name
  ```
  Every time the partner name is changed, the description is modified.


## Chapter 12: Inheritance

- A powerful aspect of Odoo is its modularity.
- A module is dedicated to a business need, but modules can also interact with one another.
- This is useful for extending the functionality of an existing module.
- For example, in our real estate scenario we want to display the list of a salesperson's properties directly in the regular user view.
- But before going through the specific Odoo module inheritance, let's see how we can alter the behaviour of the standard CRUD (Create, Retrieve, Update, Delete) methods.

### Python Inheritance

- In our real estate module, we never had to develop anything specific to be able to do the standard CRUD actions. The Odoo framework provides the necessary tools to do them. In fact, such actions are already included in our model thanks to classical Python inheritance:
  ```python
  from odoo import fields, models

  class TestModel(models.Model):
      _name = "test_model"
      _description = "Test Model"

      ...
  ```
- Our `class TestModel` inherits from Model, which provides `create()`, `read()`, `write()`, and `unlink()`.
- These methods (and any other method definced on Model) can be extended to add specific business logic:
  ```python
  from odoo import fields, models

  class TestModel(models.Model):
      _name = "test_model"
      _description = "Test Model"

      ...

      @api.model
      def create(self, vals):
          # Do sem business logis, modify vals...
          ...
          # Then call super to execute the parent method
          return super().create(vals)
  ```
- The decorate `model()` is necessary for the `create()` method because the content of the recordset `self` is not relevant in the context of creation, but it is not necessary for the other CRUD methods.
- It is also important to note that even though we can directly override the `unlink()` method, you will almost always want to write a new method with the decorate `ondelete()` instead.
- Methods marked with this decorator will be called during `unlink()` and avoids some issues that cna occur during uninstalling the model's modlule when `unlink()` is directly overridden.
- In Python 3, `super()` is equivalent to `super(TestModel, self)`. The latter may be necessary when you need to call the parent method with a modified recordset.

> **Danger**
>
> - It is very important to **always** call `super()` to avoid breaking the flow. There are only a few very specific cases where you don't want to call it.
> - Make suer to always return data consistent with the parent method. For example, if the parent method returns a `dict()`, you override must also return a `dict()`.

### Model Inheritance

**Reference**: the documentation related to this topic can be found in [**Inheritance and extension**](https://www.odoo.com/documentation/17.0/developer/reference/backend/orm.html#reference-orm-inheritance).

- In our real estate module, we would like to display the list of properties linked to a salesperson directly in the Settings/Users & Companies/Users form view.
- To do this, we need to add a field to the `res.users` model and adapt its view to show it.
- Odoo provides two inheritance mechanisms to extend an existing model in a modular way.
- The first inheritance mechanism allows modules to modify the behavior of a model defined in an another module by:
  - adding fields to the model,
  - overriding the definition of fields in the model,
  - adding constraints to the model,
  - adding methods to the model,
  - overriding existing methods in the model
- The second inheritance mechanism (delegation) allows every record of a model to be linked to a parent mdoel's record and provides transparent acces to the fields of this parent record.
- In Odoo, the first mechanism is by fat the most used.
- In our case, we want to add a field to an existing model, which means we will use the first mechanism. For example:
  ```python
  from odoo import fields, models

  class InheritedModel(models.Model):
      _inherit = "inherited.model"

      new_field = fields.Char(string="New Field")
  ```
- A practical example where two fields are added to a model can be found [**here**](https://github.com/odoo/odoo/blob/60e9410e9aa3be4a9db50f6f7534ba31fea3bc29/addons/account_fleet/models/account_move.py#L39-L47).
- By convention, each inherited model is defined in its own Python file. In our example, it would be `models/inherited_model.py`.

### View Inheritance

**Reference**: the documentation related to this topic can be found in [**Inheritance**](https://www.odoo.com/documentation/17.0/developer/reference/user_interface/view_records.html#reference-view-records-inheritance).

- Insetad of modifying existing views in plave (by overwriting them), Odoo provides view inheritance where children 'extension' views are applied on top of root views.
- These extension can both add and remove content from their parent view.
- An extension view references its parent using the `inherit_id` field.
- instead of a single view, its `arch` field contains a number of `xpath` elements that select and alter the content of their parent view:
  ```xml
  <record id="inherited_model_view_form" model="ir.ui.view">
      <field name="name">inherited.model.form.inherit.test</field>
      <field name="model">inherited.model</field>
      <field name="inherit_id" ref="inherited.inherited_model_view_form"/>
      <field name="arch" type="xml">
          <!-- find field description and add the field
               new_field after it -->
          <xpath expr="//field[@name='description']" position="after">
            <field name="new_field"/>
          </xpath>
      </field>
  </record>
  ```
- `expr`, an [**XPath**](https://w3.org/TR/xpath)  expression selecting a single element in the parent view. Raises an error if it matches no element or more than one.
- `position`, operation to apply to matched element:
  - `inside`, appends `xpath`'s body to the end of the matched element.
  - `replace`, replaces the matched element with the `xpath`'s body, replacing any `$0` node occurrence in the new body with the original element.
  - `after`, inserts the `xpath`'s body as a sibling after the matched element.
  - `attributes`, alters the attributes of the matched element using the special `attribute` elements in the `xpath`'s body.

- When matching a single element, the `position` attribute can be set directly on the element to be found. Both, inheritances below have the same result.
  ```xml
  <xpath expr="//field[@name='description']" position="after">
      <field name="idea_ids" />
  </xpath>

  <field name="description" position="after">
      <field name="idea_ids" />
  </field>
  ```
- An example of a view inheritance extensin can be found [**here**](https://github.com/odoo/odoo/blob/691d1f087040f1ec7066e485d19ce3662dfc6501/addons/account_fleet/views/account_move_views.xml#L3-L17).
- Inheritance is extensively used in Odoo due to its modular concept.
- Do not hesitate to read the corresponding documentation for more info!


## Chapter 13: Interact with Other Modules

- In the previous chapter, we used inheritance to modify the behavior of a module.
- In our real estate scenario, we would like to go a step further and be able to generate invoices for our customers.
- Odoo provides an Invoicing module, so it would be neat to create an invoice directly from our real estate module, i.e. once a property is set to 'Sold', an invoice is created in the Invoicing application.

### Concrete Example: Account Move

- Any time we interact with another module, we need to keep in mind the modularity.
- If we intend to sell our application to real estate agencies, some may want the invoicing feature but others may not want it.

#### Link Module

- The common approach for such use cases is to create a 'link' module.
- In our case, the module would depend on `estate` and `account` and would include the invoice creation logic of the estate property.
- This way the real estate and the accounting modules can be installed independently.
- Then both are installed, the link module provides the new feature.
- When the `estate_account` moduel apprars in the list, go ahead and install it!
- You'll notice thtat the Invoicing application is installed as well. This is expected since your module depends on it.
- If you uninstall the Invoicing application, your module will be uninstalled as well.

#### Invoice Creation

- It's now time to generate the invoice.
- We want to add functionality to the `estate.property` model, i.e. we want to add some extra logic for when a property is sold.
- Does that sound familiar? If not, it's a good idea to go back to the previous chapter since you might have missed something ;-)
- As a first step, we need to extend the action called when pressing the 'Sold' button on a property.
- To do so, we need to create a [**model inheritance**](https://www.odoo.com/documentation/17.0/developer/tutorials/server_framework_101/12_inheritance.html) in the `estate_account` module for the `estate.property` model.
- For now, the overridden action will simply return the `super` call. Mybe an example will make things clearer:
  ```python
  from odoo import models

  class InheritedModel(models.Model):
      _inherit = "inherited.model"

      def inherited_action(self):
          return super().inherited_action()
  ```
- A practical example can be found [**here**](https://github.com/odoo/odoo/blob/f1f48cdaab3dd7847e8546ad9887f24a9e2ed4c1/addons/event_sale/models/account_move.py#L7-L16).
- If the override iw working, we can move forward and create the invoice.
- Unforunately, there is no easy way to know how to create any given object in Odoo.
- Most of the time, it is necessary to have a look at its model to find the required fields and provide appropirate values.
- A good way to learn is to look at how other modules already do what you want to do.
- For example, one of the basic flows of Sales is the creation of an Invoice from a Sales Order.
- This looks like a good starting point since it does exactly what we want to do.
- Take some time to read and understand the [\_create_invoice](https://github.com/odoo/odoo/blob/f1f48cdaab3dd7847e8546ad9887f24a9e2ed4c1/addons/sale/models/sale.py#L610-L717) method.
- When you are done crying because this simple task looks awfully complex, we can move forward in the tutorial.
- To create an invoice, we need the following information:
  - a `partner_id`: the customer
  - a `move_type`: it has several [**possible values**](https://github.com/odoo/odoo/blob/f1f48cdaab3dd7847e8546ad9887f24a9e2ed4c1/addons/account/models/account_move.py#L138-L147)
  - a `journal_id`: the accounting journal
- This is enough to create an empty invoice.

- When a propety is set to 'Sold', you should now have a new customer invoice created in Invoicing / Customers / Invoices.
- Obviously we don't have any invoice lines so far. To create an invoice line, we need the following information:
  - `name` a secription of the line
  - `quantity`
  - `price_unit`

- Moreover, an invoice line need to be linked to an invoice.
- The easiest and most efficient way to link a line to an invoice is to include all lines at invoice creation.
- To do this, the `invoice_line_ids` field is included in the `account.move` creation, which is a `One2many`.
- One2many and Many2many use special 'commands'which have been made human readable with the `Command` namespace.
- This namespace represents a triplet command to execute on a set of records.
- The triplet was originally the only option to do these commands, but it is now standard to use the namespace instead.
- The format is to place them in a list which is executed sequentially.
- Here is a simple example to include a One2many field `line_ids` at creation of a `test_model`:
  ```python
  form odoo import Command

  def inherited_action(self):
      self.env['test.model'].create(
          {
              'name': "Test",
              'line_ids': [
                  Command.create({
                      'field1': 'value_1',
                      'field2': 'value_2',
                  })
              ],
          }
      )
      return super().inherited_action()
  ```


## Chapter 14: A Brief History of QWeb

- So fat the interface design of our real estate module has been rather limited.
- Building a list view is strightforward since only the list of fields is necessary.
- The same holds true for the form view: despite the use of a few tags such as `<group>` or `<page>`, there is very little to do in terms of design.
- However, if we want to give a unique look to our application, it is necessary to go a step further and be able to design new views.
- Moreover, other features such as PDF reports or website pages need another tool to be created with more flexibility: a [**templating**](https://en.wikipedia.org/wiki/Template_processor) engine.
- You probably already have come across the [**kanban board**](https://en.wikipedia.org/wiki/Kanban_board) in Odoo where the records are displayed in a card-like structure.
- We will build a such a view for our real estate module.

### Concrete Example: A Kanban View

**Reference**: the documentation related to this topic can be found in [**Kanban**](https://www.odoo.com/documentation/17.0/developer/reference/user_interface/view_architectures.html#reference-view-architectures-kanban).

- In our estate application, we would like to add a Kanban view to display our properties.
- Kanban views are a standard Odoo view (like the form and list views), but their structure is much more flexible.
- In fact, the structure of each card is a mix of form elements (including basic HTML) and QWeb.
- The definition of a Kanban view is similar to the definition of the list and form views, except that their root element is `<kanban>`.
- In its simplest form, a Kanban view looks like:
  ```xml
  <kanban>
      <templates>
          <t t-name="kanban-box">
              <div class="oe_kanban_global_click">
                  <field name="name"/>
              </div>
          </t>
      </templates>
  </kanban>
  ```
- Let's break down this example:
  - `template`: defines a list of [**QWeb Temolates**](https://www.odoo.com/documentation/17.0/developer/reference/frontend/qweb.html#reference-qweb) templates. Kanban views must define at least one root template `kanban-box`, which will be rendered once for each record.
  - `<t t-name="kanban-box">`: `<t>` is a placeholder element for QWeb directives. In this case, it is used to set the `name` of the template to `kanban-box`
  - `<div class="oe_kanban_global_click">`: the `oe_kanban_global_click` makes the `<div>` clickable to opoen the record.
  - `<field name="name"/>`: this will add the `name` field to the view.

- Once the kanban view is working, we can start imporving it.
- If we want to display an element conditionally, we can use the `t-if` directive (see [**Conditionals**](https://www.odoo.com/documentation/17.0/developer/reference/frontend/qweb.html#reference-qweb-conditionals)).
  ```xml
  <kanban>
      <field name="state"/>
      <templates>
          <t t-name="kanban-box">
              <div class="oe_kanban_global_click">
                  <field name="name"/>
                  <div t-if="record.state.raw_value == 'new'">
                      This is new!
                  </div>
              </div>
          </t>
      </templates>
  </kanban>
  ```
- We added a few things:
  - `t-if`: the `<div>` element is rendered if the condition is true.
  - `record`: an object with all the requested fields as its attributes. Each field has two attributes `value` and `raw_value`. The former is formatted according to current user prameters and the latter is the dirct value from a `read()`.
- In the above example, the field `name` was added in the `<templates>` element, but `state` is outside of it.
- When we need the value of a field but don't want to display it in the view, it is possibel to add it outside of the `<templates>` element.
- Let's give the final touch to our view: the properties must be grouped by type by default.
- You might want to have a look at the various options described in [**Kanban**](https://www.odoo.com/documentation/17.0/developer/reference/user_interface/view_architectures.html#reference-view-architectures-kanban).
- Kanban views are a typical example of how it is always a good idea to start from an existing view and fine tune it instead of starting from scratch.
- There area many options and classes available, so...read and learn!


## Chapeter 15: The final word

### Coding guidelines

- We will refactoring the code to match to the Odoo coding guidelines.
- The guidelines aim to improve the quility of the Odoo APps code.

**Reference**: you will find the Odoo coding guidelines in [**Coding guidelines**](https://www.odoo.com/documentation/17.0/contributing/development/coding_guidelines.html).

### Test on the runbot

- Odoo has it own CI server named [**runbot**](https://runbot.odoo.com/).
- All comits, branches and PR will be tested to avaoid regressions or breaking of the stable versions.
- All runs that pass the tests are deployed on their own server with demo data.
